# mem mgmt

## toc
- addr binding
- addr spaces
- swapping
- contiguous mem allocations

### mem is an important resource that must be managed carefully
- mem capacities have been increasing, but programs are getting bigger faster
- parkinson's law
  - programs expand to fill mem available to hold them

### what every programmer would like
- mem with these characteristics
  - private, infinitely large, infinitely fast
  - non-volatile
  - inexpensive
- as of now, there is no such mem

### mem hierarchy
- volatile
  - registers
  - cache
  - main mem
  - electronic disk
- non-volatile
  - magnetic disk
  - optical disk
  - magnetic tapes

## mem mgmt

### why?
- main objective of system is to execute programs
- programs & data must be in mem (at least partially) during execution
- to improve cpu utilization & response times
  - several procs need to be mem resident
  - mem needs to be shared

### mem
- large array of words (bytes)
  - each word has its own addr
- typical program execution cycle
  1. fetch instruction from mem where program is stored
  2. decode
  3. execute. operands may be fetched from mem
  4. result of execution may be stored back to mem

### why procs must be mem resident
- storage that cpu can access directly
  1. registers in cpu
  2. main mem
- machine instructions take mem addrs as arguments
  - none operate on disk addrs
- any instructions in execution plus needed data must be in mem

### overheads in direct access storage devices
- cpus can decode instructions & perform simple operations on register contents - 1+ per clock cycle
- registers accessible in 1 clock cycle
- main mem access is a transaction on mem bus - takes several cycles to complete

### coping with speed differential (hardware)
- introduce fast mem between cpu & main mem for reused data
  - cache (data)
  - cache (instructions)
  - cache (translation)
  - cache (& al.)

### we must also perform correct operation (software)
- os must be protected from accesses by user procs
- user procs must be protected from eachother

### protection: making sure each proc has separate mem spaces
- determine range of legal addrs for proc
- ensure proc can access only those

### providing protection with registers
- base - smallest legal physical addr
- limit - size of range of physical addrs
- e.g. base = 300040, limit = 120900
  - legal: 300040 <--> (300040 + 120900 - 1) = 420939

### base & limit registers loaded only by os
- privileged instructions needed to load registers - executed only in kernel mode
- user programs cannot change contents of these registers
- os given unrestricted access to os & user's mem

### procs & mem
- to execute, a program needs to be placed inside a proc
- proc executes
  - access instructions & data from mem
- proc terminates
  - mem reclaimed & declared available

### binding is a mapping from 1 addr space to the next
- procs can reside in any part of physical mem
  - 1st addr of proc need not be `x0000` (duh)
- addrs in source program are symbolic
- compiler binds symbolic addrs to relocatable addrs
- loader binds relocatable addrs to absolute addrs

### binding can be done at different times
- compile time
  - known that proc will reside at location R
    - if location changes, recompile
  - ms-dos.com programs were bound this way
- load time
  - based on compiler-generated relocatable code
- execution time
  - proc can be moved around during execution
    - binding delayed until runtime
    - special hardware neededd
    - supported by most os

## addr spaces

### addr spaces
- logical
  - addrs generated by program running on cpu
- physical
  - addrs seen by mem unit
- logical addr space - set of logical addrs generated by program
- physical addr space - set of physical addrs corresponding to logical addr space

### mem mgmt unit
- mapping converts logical to physical addrs
- user program never sees real physical addr
  - create pointer to location
  - store in mem, manipulate & compare
- when used as mem addr (load/store)
  - relocated to physical mem

### generation of physical & logical addrs
- compile time & load time
  - identical logical & physical addrs
- execution time
  - logical addrs differ from physical addrs
  - logical addr referred to as virtual addr
- runtime mapping performed in hardware via mem mgmt unit (mmu)

#### but do we need to load entire program in mem?
- no. only what we need to execute

### in dynamic loading, an unused routine is never loaded into mem
- routine not loaded until called
  - kept on disk in relocatable load format
- when routine calls another one
  - if routine not present, load it & update addr tables
- does not require special support from os
  - design programs appropriately

### contrasting loading & linking
- loading - load executable into mem prior to execution
- linking - takes some smaller executables & joins them together as a single larger executable

### static linking
- language libs treated as other modules
  - combined by loader into program image
- each program includes a copy of lib functions called in executable image
  - wastes disk/mem space, but makes binary self-contained

### dynamic linking
- similar to dynamic loading
- stub included for each lib reference
  - locate mem resident routine
  - how to load routine if not in mem
- after routine loaded, stub replaces itself with addr of routine
  - subsequent accesses to code segment do not incur dynamic linking costs

### unlike dynamic loading, dynamic linking needs os support
- only os can allow multiple procs to access same mem region
  - shared pages

## swapping

### swapping & mem space restrictions: effects of binding
- proc may/may not be swapped back into same space that it occupied
- binding at compile/load time - difficult to relocate
- execution time binding
  - proc can be swapped into different mem spaces
  - physical addrs computed at runtime

### when cpu scheduler decies to execute a proc, it calls dispatcher
- check whether next proc is in mem
- if next proc not in mem & no free mem
  - swap out a proc that is mem resident
  - swap in desired proc

### overheads in swapping: context switch time
- user proc size: 100MB
- transfer rate: 50MB/s
- transfer time: 2s
- avg latency: 8ms
- swap out = transfer time + latency = 2008ms
- total swap time = swap in + swap out = 4016ms

### factors constraining swapping besides swap time
- proc must be completely idle
  - no pending i/o
- device is busy so i/o is queued
  - swap out P~1~ & swap in P~2~
  - i/o operation may attempt to use P~2~'s mem
    - solution 1: never swap proc with pending i/o
    - solution 2: execute i/o operations into os buffers

### swapping not a reasonable mem mgmt solution
- too much swapping time, too little execution time
- modification of swapping exists in many versions of unix
  - swapping normally disabled
  - starts if many procs are running & set threshold is breached
  - halted when system load reduces

## contiguous mem allocation
- each proc contained in a single continuous setion of mem

### partitioning of mem
- main mem needs to accomodate os & user proc
- divided into 2 partitions
  - resident os (usually low)
  - user procs

### mem mapping & protection
- relocation register - smallest physical addr
- limit register - range of logical addrs
- when cpu scheduler selects a proc for execution
  - relocation & limit registers reloaded as part of context switch
- every addr generated by cpu checked against relocation/limit registers

### mem allocation: fixed partition method
- divide mem into several fixed size partitions
  - each partition contains exactly 1 proc
- degree of multiprogramming bound by num partitions

### mem allocation: variable partition method
- used in batch environments
- os maintains table tracking mem utilization
  - what is available?
  - which ones are occupied?
- initially all mem available
  - considered large mem hole
  - eventually many mem holes will exist
- os orders procs according to scheduling algorithm
- mem allocated to procs until requirements of next proc cannot be met
  - wait until larger block available
  - check if smaller requirements of other procs can be met
- reclaiming spaces
  - when proc arrives if space too large, split into 2
  - when proc terminates
    - if released mem adjacent to other mem holes, fuse to form larger space

